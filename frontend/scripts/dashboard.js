import {
  buildQuestCard,
  createChipRow,
  formatNumber,
  prettifySkillName,
} from "../components/QuestCard.js";
import { addHeader } from "../components/utils.js";

addHeader();
const userId = window.localStorage.getItem("userId");
const dashboardState = {
  submissions: [],
  questsJoined: [],
  questsCreated: [],
  joinedQuestIds: new Set(),
  pendingJoinedQuestIds: [],
};
let skip = 0;
const limit = 10;
const userProfile = await getUserProfile();
if (userProfile) {
  buildProfilePageStructure(userProfile);
} else {
  renderEmptyState();
}

async function getUserSubmissions() {
  // Fetch paginated submissions for infinite scroll
  const submissions = await (
    await fetch(`/submissions/${userId}?skip=${skip}&limit=${limit}`)
  ).json();
  skip += limit;
  submissions.forEach((submission) => {
    const challengeId = submission?.challengeId;
    if (!challengeId) {
      return;
    }
    if (!dashboardState.joinedQuestIds.has(challengeId)) {
      dashboardState.joinedQuestIds.add(challengeId);
      dashboardState.pendingJoinedQuestIds.push(challengeId);
      console.debug(
        `[submissions] queued new quest id from submission: ${challengeId}`
      );
    }
  });
  return submissions;
}

async function getUserJoinedQuests(ids) {
  const questIds =
    Array.isArray(ids) && ids.length
      ? ids
      : Array.from(dashboardState.joinedQuestIds);
  if (!questIds.length) {
    return [];
  }

  const quests = await (
    await fetch(`/quests/joined/questIdArray`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ userId, questIdArray: questIds }),
    })
  ).json();

  // Remove fetched ids from pending list
  if (Array.isArray(ids) && ids.length) {
    const toRemove = new Set(ids.map(String));
    dashboardState.pendingJoinedQuestIds = dashboardState.pendingJoinedQuestIds.filter(
      (id) => !toRemove.has(String(id)),
    );
  }

  return quests;
}

async function getUserCreatedQuests() {
  const questsCreated = await (await fetch(`/quests/${userId}`)).json();
  return questsCreated;
}

async function getUserProfile() {
  const submissions = await getUserSubmissions();

  const user = await (await fetch(`/user/${userId}`)).json();
  const questsJoined = await getUserJoinedQuests(
    Array.isArray(dashboardState.pendingJoinedQuestIds)
      ? [...dashboardState.pendingJoinedQuestIds]
      : []
  );
  const questsCreated = await getUserCreatedQuests();
  console.log({ user, questsJoined, submissions, questsCreated });
  return { user, questsJoined, submissions, questsCreated };
}

// Structure and style generated by GPT 5

function renderEmptyState() {
  injectDashboardStyles();
  const body = document.body;
  body.classList.add("dashboard-body");

  const main = document.createElement("main");
  main.className = "dashboard";

  const notice = document.createElement("div");
  notice.className = "empty-state";
  notice.textContent =
    "We couldn't load your profile right now. Please try again shortly.";

  main.appendChild(notice);
  body.appendChild(main);
}

function buildProfilePageStructure(profileData) {
  injectDashboardStyles();

  const {
    user = [],
    submissions = [],
    questsJoined = [],
    questsCreated = [],
  } = profileData;

  const userInfo = Array.isArray(user) ? user[0] : user;

  if (!userInfo || Object.keys(userInfo).length === 0) {
    renderEmptyState();
    return;
  }

  const joinedList = Array.isArray(questsJoined?.data)
    ? questsJoined.data
    : Array.isArray(questsJoined)
      ? questsJoined
      : [];

  const createdList = Array.isArray(questsCreated?.data)
    ? questsCreated.data
    : Array.isArray(questsCreated)
      ? questsCreated
      : [];

  dashboardState.submissions = Array.isArray(submissions)
    ? [...submissions]
    : [];
  dashboardState.questsJoined = [...joinedList];
  dashboardState.questsCreated = [...createdList];

  const questIdSet = new Set(
    dashboardState.questsJoined.map((quest) => quest?._id).filter(Boolean)
  );
  dashboardState.pendingJoinedQuestIds = [];
  dashboardState.submissions.forEach((submission) => {
    const challengeId = submission?.challengeId;
    if (challengeId && !questIdSet.has(challengeId)) {
      questIdSet.add(challengeId);
      dashboardState.pendingJoinedQuestIds.push(challengeId);
    }
  });
  dashboardState.joinedQuestIds = questIdSet;

  const body = document.body;
  body.classList.add("dashboard-body");

  const main = document.createElement("main");
  main.className = "dashboard";

  const heroSection = buildHeroSection(userInfo);
  main.appendChild(heroSection);

  const tabs = [
    {
      id: "stats",
      label: "Stats",
      panelClass: "stats-panel",
      builder: () => buildStatsPanel(userInfo, joinedList, submissions),
    },
    {
      id: "submissions",
      label: "Submissions",
      count: submissions.length,
      panelClass: "submissions-panel",
      builder: () => buildSubmissionsPanel(submissions),
    },
    {
      id: "questsJoined",
      label: "Quests Joined",
      count: joinedList.length,
      panelClass: "quests-panel",
      builder: () => buildQuestsPanel(joinedList, "joined"),
    },
    {
      id: "questsCreated",
      label: "Quests Created",
      count: createdList.length,
      panelClass: "quests-panel",
      builder: () => buildQuestsPanel(createdList, "created"),
    },
  ];

  const tabSection = buildTabSection(tabs);
  main.appendChild(tabSection);
  body.appendChild(main);
}

function buildHeroSection(userInfo) {
  const {
    username = "Creator",
    email = "",
    avatarUrl = "",
    stats = {},
  } = userInfo;

  const heroSection = document.createElement("section");
  heroSection.className = "profile-hero";

  const profileCard = document.createElement("div");
  profileCard.className = "profile-card";

  const avatar = document.createElement("img");
  avatar.className = "profile-avatar";
  avatar.src =
    avatarUrl || "https://dummyimage.com/200x200/1a1a1a/ffffff&text=Profile";
  avatar.alt = `${username}'s avatar`;

  const identity = document.createElement("div");
  identity.className = "profile-meta";

  const nameEl = document.createElement("h1");
  nameEl.textContent = username;

  const emailEl = document.createElement("p");
  emailEl.className = "profile-email";
  emailEl.textContent = email;

  identity.append(nameEl, emailEl);
  profileCard.append(avatar, identity);

  const statsGrid = document.createElement("div");
  statsGrid.className = "stats-grid";

  // Derive live stats from loaded data to reflect actual values
  const submissionsCount = Array.isArray(dashboardState.submissions)
    ? dashboardState.submissions.length
    : 0;
  const questsJoinedCount = Array.isArray(dashboardState.questsJoined)
    ? dashboardState.questsJoined.length
    : 0;
  // Treat "Quests Started" as quests the user created
  const questsStartedCount = Array.isArray(dashboardState.questsCreated)
    ? dashboardState.questsCreated.length
    : 0;

  const statEntries = [
    { label: "Submissions", value: submissionsCount },
    { label: "Quests Joined", value: questsJoinedCount },
    { label: "Quests Started", value: questsStartedCount },
  ];

  statEntries.forEach(({ label, value }) => {
    const statCard = document.createElement("article");
    statCard.className = "stat-card";

    const statValue = document.createElement("span");
    statValue.className = "stat-value";
    statValue.textContent = formatNumber(value);

    const statLabel = document.createElement("span");
    statLabel.className = "stat-label";
    statLabel.textContent = label;

    statCard.append(statValue, statLabel);
    statsGrid.appendChild(statCard);
  });

  heroSection.append(profileCard, statsGrid);
  return heroSection;
}

function buildTabSection(tabs) {
  const container = document.createElement("section");
  container.className = "tab-container";

  const nav = document.createElement("nav");
  nav.className = "tab-nav";
  const list = document.createElement("ul");
  list.className = "tab-list";
  nav.appendChild(list);

  const panelsWrapper = document.createElement("div");
  panelsWrapper.className = "tab-panels";

  tabs.forEach((tab, index) => {
    const item = document.createElement("li");

    const button = document.createElement("button");
    button.type = "button";
    button.className = "tab-button";
    button.dataset.tab = tab.id;

    const labelSpan = document.createElement("span");
    labelSpan.textContent = tab.label;
    button.appendChild(labelSpan);

    if (typeof tab.count === "number") {
      const countSpan = document.createElement("span");
      countSpan.className = "tab-count";
      countSpan.textContent = formatNumber(tab.count);
      button.appendChild(countSpan);
    }

    if (index === 0) {
      button.classList.add("active");
    }

    button.addEventListener("click", () => setActive(tab.id));

    item.appendChild(button);
    list.appendChild(item);

    const panel = document.createElement("section");
    panel.className = "tab-panel";
    if (tab.panelClass) {
      panel.classList.add(tab.panelClass);
    }
    panel.dataset.tab = tab.id;
    if (index === 0) {
      panel.classList.add("active");
    }

    panel.appendChild(tab.builder());
    panelsWrapper.appendChild(panel);
  });

  function setActive(id) {
    container
      .querySelectorAll(".tab-button")
      .forEach((btn) => btn.classList.toggle("active", btn.dataset.tab === id));
    panelsWrapper
      .querySelectorAll(".tab-panel")
      .forEach((panel) =>
        panel.classList.toggle("active", panel.dataset.tab === id)
      );
  }

  container.append(nav, panelsWrapper);
  return container;
}

function buildStatsPanel(userInfo, joinedList, submissions) {
  const panel = document.createElement("div");
  panel.className = "stats-panel-content";

  const skills = userInfo.skills ?? {};
  const stats = userInfo.stats ?? {};

  const insightGrid = createInsightGrid(skills, stats, submissions, joinedList);
  const skillsSection = createSkillsSection(skills);
  if (skillsSection) {
    panel.appendChild(skillsSection);
  }

  if (insightGrid) {
    panel.appendChild(insightGrid);
  }

  return panel;
}

function createInsightGrid(skills, stats, submissions, joinedList) {
  const metrics = [];

  const totalSubmissions = stats.submissionsCount ?? submissions.length ?? 0;
  metrics.push({
    label: "Total Submissions",
    value: formatNumber(totalSubmissions),
  });

  const totalLikes = submissions.reduce(
    (acc, submission) => acc + (submission?.counters?.likes ?? 0),
    0
  );
  metrics.push({ label: "Total Likes", value: formatNumber(totalLikes) });

  const activeQuests = stats.questsJoined ?? joinedList.length ?? 0;
  metrics.push({ label: "Active Quests", value: formatNumber(activeQuests) });

  const skillEntries = Object.entries(skills ?? {});
  if (skillEntries.length) {
    const [topSkillKey] = skillEntries.sort((a, b) => b[1] - a[1])[0];
    metrics.push({
      label: "Top Skill",
      value: prettifySkillName(topSkillKey),
    });
  }

  const latestSubmission = submissions
    .map((submission) => {
      const date = new Date(submission.createdAt ?? submission.updatedAt);
      return {
        date,
        createdAt: submission.createdAt,
      };
    })
    .filter(({ date }) => !Number.isNaN(date.getTime()))
    .sort((a, b) => b.date.getTime() - a.date.getTime())[0];

  if (latestSubmission) {
    metrics.push({
      label: "Last Submission",
      value: formatDate(latestSubmission.createdAt),
    });
  }

  if (!metrics.length) {
    return null;
  }

  const insightGrid = document.createElement("div");
  insightGrid.className = "insight-grid";

  metrics.forEach(({ label, value }) => {
    const card = document.createElement("article");
    card.className = "insight-card";

    const valueEl = document.createElement("span");
    valueEl.className = "insight-value";
    valueEl.textContent = value;

    const labelEl = document.createElement("span");
    labelEl.className = "insight-label";
    labelEl.textContent = label;

    card.append(valueEl, labelEl);
    insightGrid.appendChild(card);
  });

  return insightGrid;
}

function createSkillsSection(skills = {}) {
  const skillEntries = Object.entries(skills ?? {});
  const maxSkillValue = skillEntries.length
    ? Math.max(...skillEntries.map(([, value]) => value))
    : 0;

  const skillsSection = document.createElement("section");
  skillsSection.className = "profile-section skills-section";

  const sectionHeader = document.createElement("div");
  sectionHeader.className = "section-header";

  const skillsHeading = document.createElement("h2");
  skillsHeading.textContent = "Skill Breakdown";
  sectionHeader.appendChild(skillsHeading);

  if (skillEntries.length) {
    const skillsCount = document.createElement("span");
    skillsCount.className = "section-pill";
    skillsCount.textContent = `${skillEntries.length} skills`;
    sectionHeader.appendChild(skillsCount);
  }

  if (!skillEntries.length || maxSkillValue === 0) {
    const emptySkills = document.createElement("p");
    emptySkills.className = "skills-empty";
    emptySkills.textContent = "No skills to display yet.";
    skillsSection.append(sectionHeader, emptySkills);
    return skillsSection;
  }

  const skillsLayout = document.createElement("div");
  skillsLayout.className = "skills-layout";

  const sortedSkills = [...skillEntries].sort((a, b) => b[1] - a[1]);

  const radarColumn = document.createElement("aside");
  radarColumn.className = "skills-radar";

  const radarTitle = document.createElement("h3");
  radarTitle.className = "radar-title";
  radarTitle.textContent = "Balance overview";

  const radarWrapper = document.createElement("div");
  radarWrapper.className = "radar-wrapper";
  radarWrapper.appendChild(buildRadarChart(sortedSkills, maxSkillValue));

  radarColumn.append(radarTitle, radarWrapper);

  const skillsGrid = document.createElement("div");
  skillsGrid.className = "skills-grid";

  sortedSkills.forEach(([skillKey, rawValue], index) => {
    const percentage = maxSkillValue
      ? Math.round((rawValue / maxSkillValue) * 100)
      : 0;

    const card = document.createElement("article");
    card.className = "skill-card";

    const header = document.createElement("div");
    header.className = "skill-card-header";

    const name = document.createElement("span");
    name.className = "skill-name";
    name.textContent = prettifySkillName(skillKey);

    const rank = document.createElement("span");
    rank.className = "skill-rank";
    rank.textContent = `#${index + 1}`;

    header.append(name, rank);

    const scoreRow = document.createElement("div");
    scoreRow.className = "skill-score-row";

    const score = document.createElement("span");
    score.className = "skill-score";
    score.textContent = formatNumber(rawValue);

    const percent = document.createElement("span");
    percent.className = "skill-percent";
    percent.textContent = `${percentage}%`;

    scoreRow.append(score, percent);

    const progress = document.createElement("div");
    progress.className = "skill-progress";

    const fill = document.createElement("div");
    fill.className = "skill-progress-fill";
    fill.style.width = `${percentage}%`;
    fill.setAttribute("data-percent", percentage);

    progress.appendChild(fill);

    card.append(header, scoreRow, progress);
    skillsGrid.appendChild(card);
  });

  skillsLayout.append(radarColumn, skillsGrid);
  skillsSection.append(sectionHeader, skillsLayout);
  return skillsSection;
}

function buildSubmissionsPanel(submissions = []) {
  return createPaginatedPanel({
    key: "submissions",
    items: submissions,
    renderItem: buildSubmissionCard,
    wrapperClass: "submissions-panel-content",
    gridClass: "submissions-grid",
    emptyMessage: "No submissions yet. Capture your first story.",
    fetchMore: fetchMoreSubmissions,
  });
}

function buildSubmissionCard(submission) {
  const { title, imageUrl, counters = {}, createdAt, exif = {} } = submission;

  const card = document.createElement("article");
  card.className = "entry-card submission-card";

  const thumbWrapper = document.createElement("div");
  thumbWrapper.className = "entry-thumb-wrapper";

  const thumb = document.createElement("img");
  thumb.className = "entry-thumb";
  thumb.src =
    imageUrl || "https://dummyimage.com/1600x900/101010/ffffff&text=Submission";
  thumb.alt = title ? `${title} submission preview` : "Submission preview";
  thumbWrapper.appendChild(thumb);

  const body = document.createElement("div");
  body.className = "entry-card-body";

  const titleEl = document.createElement("h3");
  titleEl.className = "entry-title";
  titleEl.textContent = title || "Untitled Submission";

  const meta = document.createElement("div");
  meta.className = "entry-meta";

  const likesSpan = document.createElement("span");
  likesSpan.textContent = `${formatNumber(counters.likes ?? 0)} likes`;

  const dateSpan = document.createElement("span");
  dateSpan.textContent = formatDate(createdAt);

  meta.append(likesSpan, dateSpan);

  body.append(titleEl, meta);

  const exifItems = [];
  if (exif?.camera) exifItems.push(exif.camera);
  if (exif?.f) exifItems.push(`ƒ/${exif.f}`);
  if (exif?.iso) exifItems.push(`ISO ${exif.iso}`);
  if (exif?.shutter) exifItems.push(exif.shutter);
  if (exif?.focal) exifItems.push(`${exif.focal}mm`);

  const exifRow = createChipRow(exifItems, "muted");
  if (exifRow) {
    body.appendChild(exifRow);
  }

  card.append(thumbWrapper, body);
  return card;
}

function buildQuestsPanel(quests = [], type = "joined") {
  const emptyMessage =
    type === "joined"
      ? "You haven't joined any quests yet."
      : "You haven't created any quests yet.";

  const renderCard =
    type === "created"
      ? (quest) =>
          buildQuestCard(quest, {
            showDelete: true,
            onDelete: async (questId, questData, card) => {
              try {
                // Call backend to delete quest by id
                const resp = await fetch(
                  `/quests/${encodeURIComponent(questId)}`,
                  {
                    method: "DELETE",
                  }
                );
                if (!resp.ok) {
                  console.error("Failed to delete quest", questId, resp.status);
                  // Keep card if backend failed
                  return false;
                }

                // Remove from local dashboard state if present
                if (
                  dashboardState &&
                  Array.isArray(dashboardState.questsCreated)
                ) {
                  dashboardState.questsCreated =
                    dashboardState.questsCreated.filter(
                      (q) =>
                        (q?._id ?? q?.id ?? q?.questId ?? q?.challengeId) !==
                        questId
                    );
                }

                // Notify listeners deletion succeeded
                card.dispatchEvent(
                  new CustomEvent("dashboard:quest-deleted", {
                    bubbles: true,
                    detail: { questId, quest: questData },
                  })
                );

                // Return truthy so QuestCard removes the element
                return true;
              } catch (err) {
                console.error("Error deleting quest", questId, err);
                return false;
              }
            },
          })
      : buildQuestCard;

  return createPaginatedPanel({
    key: type === "joined" ? "questsJoined" : "questsCreated",
    items: quests,
    renderItem: renderCard,
    wrapperClass: "quests-panel-content",
    gridClass: "quests-grid",
    emptyMessage,
    chunkSize: 6,
    fetchMore: type === "joined" ? fetchMoreJoinedQuests : undefined,
  });
}

function createEmptyPanel(message) {
  const empty = document.createElement("div");
  empty.className = "panel-empty";
  empty.textContent = message;
  return empty;
}

async function fetchMoreSubmissions() {
  console.debug("[submissions] fetching next chunk from server");
  const newItems = await getUserSubmissions();
  if (Array.isArray(newItems) && newItems.length) {
    dashboardState.submissions.push(...newItems);
  }
  return Array.isArray(newItems) ? newItems : [];
}

async function fetchMoreJoinedQuests() {
  if (!dashboardState.pendingJoinedQuestIds.length) {
    console.debug("[questsJoined] no pending quest ids to fetch");
    return [];
  }

  const nextIds = dashboardState.pendingJoinedQuestIds.splice(0, 6);
  console.debug("[questsJoined] fetching quest details for ids", nextIds);

  const response = await getUserJoinedQuests(nextIds);
  const quests = Array.isArray(response?.data)
    ? response.data
    : Array.isArray(response)
      ? response
      : [];

  if (quests.length) {
    quests.forEach((quest) => {
      if (quest?._id) {
        dashboardState.joinedQuestIds.add(quest._id);
      }
    });
    dashboardState.questsJoined.push(...quests);
  }

  return quests;
}

function createPaginatedPanel({
  key,
  items = [],
  renderItem,
  wrapperClass,
  gridClass,
  emptyMessage,
  chunkSize = 6,
  fetchMore,
}) {
  const wrapper = document.createElement("div");
  if (wrapperClass) {
    wrapper.className = wrapperClass;
  }

  const initialItems = Array.isArray(items) ? [...items] : [];

  if (!initialItems.length && !fetchMore) {
    wrapper.appendChild(createEmptyPanel(emptyMessage));
    return wrapper;
  }

  const grid = document.createElement("div");
  grid.className = ["card-grid", gridClass].filter(Boolean).join(" ");

  const sentinel = document.createElement("div");
  sentinel.className = "infinite-sentinel";
  grid.appendChild(sentinel);

  wrapper.appendChild(grid);

  const state = {
    key,
    items: initialItems,
    index: 0,
    chunkSize,
    grid,
    sentinel,
    renderItem,
    observer: null,
    loading: false,
    fetchMore,
    fetchingMore: false,
    endReached: false,
  };

  function cleanup() {
    console.debug(`[${key}] cleanup pagination`);
    if (state.observer) {
      state.observer.disconnect();
    }
    if (state.sentinel.parentNode) {
      state.sentinel.parentNode.removeChild(state.sentinel);
    }
  }

  function showEmpty() {
    cleanup();
    state.endReached = true;
    grid.remove();
    wrapper.appendChild(createEmptyPanel(emptyMessage));
  }

  async function ensureMoreItems() {
    if (!state.fetchMore || state.endReached) {
      return state.index < state.items.length;
    }

    if (state.fetchingMore) {
      return false;
    }

    state.fetchingMore = true;
    console.debug(`[${key}] requesting additional items from server`);
    try {
      const newItems = await state.fetchMore();
      const normalized = Array.isArray(newItems) ? newItems : [];
      if (normalized.length) {
        state.items = state.items.concat(normalized);
        console.debug(`[${key}] received ${normalized.length} new items`);
        return true;
      }
      console.debug(`[${key}] server returned no additional items`);
      state.endReached = true;
      return false;
    } catch (error) {
      console.error(`[${key}] fetchMore failed`, error);
      state.endReached = true;
      return false;
    } finally {
      state.fetchingMore = false;
    }
  }

  function renderSlice(slice) {
    slice.forEach((item) => {
      console.debug(`[${key}] rendering item`, item);
      const card = renderItem(item);
      state.grid.insertBefore(card, state.sentinel);
    });
  }

  async function triggerLoad() {
    if (state.loading || state.endReached) {
      return;
    }

    if (state.index >= state.items.length) {
      const hasMore = await ensureMoreItems();
      if (!hasMore) {
        if (state.index === 0) {
          showEmpty();
        } else {
          cleanup();
        }
        return;
      }
    }

    if (state.index >= state.items.length) {
      return;
    }

    state.loading = true;
    if (state.observer) {
      state.observer.unobserve(state.sentinel);
    }

    const slice = state.items.slice(state.index, state.index + state.chunkSize);
    renderSlice(slice);
    state.index += slice.length;
    console.debug(
      `[${key}] appended ${slice.length} items; next index=${state.index}`
    );
    state.loading = false;

    if (state.index >= state.items.length) {
      if (state.fetchMore && !state.endReached) {
        console.debug(`[${key}] awaiting more data to become available`);
        if (state.observer) {
          state.observer.observe(state.sentinel);
        }
      } else {
        console.debug(`[${key}] all items rendered and no more data`);
        cleanup();
      }
    } else if (state.observer) {
      state.observer.observe(state.sentinel);
    }
  }

  state.observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          console.debug(`[${key}] sentinel intersecting`);
          triggerLoad();
        }
      });
    },
    { root: null, rootMargin: "200px 0px" }
  );

  console.debug(`[${key}] initializing pagination`);
  triggerLoad();
  if (!state.endReached) {
    state.observer.observe(state.sentinel);
  }

  return wrapper;
}

function formatDate(value) {
  if (!value) return "—";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }
  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  }).format(date);
}

function buildRadarChart(skillEntries, maxValue) {
  const svgNS = "http://www.w3.org/2000/svg";
  const size = 280;
  const padding = 40;
  const center = size / 2;
  const radius = center - padding;
  const levels = 4;
  const totalAxes = skillEntries.length;
  const effectiveMax =
    maxValue ?? Math.max(...skillEntries.map(([, value]) => value));

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
  svg.setAttribute("role", "img");
  svg.classList.add("radar-chart");

  for (let level = 1; level <= levels; level += 1) {
    const ratio = level / levels;
    const points = skillEntries
      .map((_, index) => {
        const angle = getAngle(index, totalAxes);
        const { x, y } = polarToCartesian(
          center,
          center,
          radius * ratio,
          angle
        );
        return `${x},${y}`;
      })
      .join(" ");
    const polygon = document.createElementNS(svgNS, "polygon");
    polygon.setAttribute("points", points);
    polygon.classList.add("radar-grid");
    svg.appendChild(polygon);
  }

  skillEntries.forEach((_, index) => {
    const angle = getAngle(index, totalAxes);
    const { x, y } = polarToCartesian(center, center, radius, angle);
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", center);
    line.setAttribute("y1", center);
    line.setAttribute("x2", x);
    line.setAttribute("y2", y);
    line.classList.add("radar-axis");
    svg.appendChild(line);
  });

  const dataPoints = skillEntries.map(([, value], index) => {
    const ratio = effectiveMax ? value / effectiveMax : 0;
    const angle = getAngle(index, totalAxes);
    return polarToCartesian(center, center, radius * ratio, angle);
  });

  const dataPolygon = document.createElementNS(svgNS, "polygon");
  dataPolygon.setAttribute(
    "points",
    dataPoints.map(({ x, y }) => `${x},${y}`).join(" ")
  );
  dataPolygon.classList.add("radar-data");
  svg.appendChild(dataPolygon);

  dataPoints.forEach(({ x, y }) => {
    const dot = document.createElementNS(svgNS, "circle");
    dot.setAttribute("cx", x);
    dot.setAttribute("cy", y);
    dot.setAttribute("r", 4.5);
    dot.classList.add("radar-point");
    svg.appendChild(dot);
  });

  skillEntries.forEach(([label], index) => {
    const angle = getAngle(index, totalAxes);
    const labelRadius = radius * 0.78;
    const { x, y } = polarToCartesian(center, center, labelRadius, angle);
    const text = document.createElementNS(svgNS, "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y);
    text.classList.add("radar-label");
    text.textContent = prettifySkillName(label);

    const alignmentAdjustment =
      angle === -Math.PI / 2
        ? { anchor: "middle", dy: "-0.35em" }
        : angle === Math.PI / 2
          ? { anchor: "middle", dy: "1em" }
          : angle > -Math.PI / 2 && angle < Math.PI / 2
            ? { anchor: "start", dy: "0.35em" }
            : { anchor: "end", dy: "0.35em" };

    text.setAttribute("text-anchor", alignmentAdjustment.anchor);
    text.setAttribute("dy", alignmentAdjustment.dy);
    svg.appendChild(text);
  });

  return svg;
}

function getAngle(index, total) {
  return (Math.PI * 2 * index) / total - Math.PI / 2;
}

function polarToCartesian(cx, cy, radius, angle) {
  return {
    x: cx + radius * Math.cos(angle),
    y: cy + radius * Math.sin(angle),
  };
}

function injectDashboardStyles() {
  if (document.getElementById("dashboard-styles")) {
    return;
  }

  const style = document.createElement("style");
  style.id = "dashboard-styles";
  style.textContent = `
:root {
  --bg: #0a0a0a;
  --panel: #151515;
  --panel-2: #1c1c1c;
  --text: #f4f4f4;
  --muted: #b8b8b8;
  --accent: #f77e2d;
  --accent-soft: rgba(247, 126, 45, 0.35);
  --ring: rgba(247, 126, 45, 0.35);
  --shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
  --radius: 16px;
}

body.dashboard-body {
  min-height: 100dvh;
  background: radial-gradient(1200px 600px at 10% -10%, #121212 0%, var(--bg) 60%) fixed;
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, system-ui, sans-serif;
  padding-bottom: 48px;
}

main.dashboard {
  width: min(1100px, 92vw);
  margin: 40px auto 0;
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.profile-hero {
  display: grid;
  gap: 24px;
  align-items: stretch;
}

.profile-card {
  display: flex;
  align-items: center;
  gap: 24px;
  padding: 24px;
  border-radius: var(--radius);
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: var(--shadow);
}

.profile-avatar {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 3px solid var(--accent-soft);
  object-fit: cover;
  background: #0d0d0d;
}

.profile-meta h1 {
  font-size: clamp(1.7rem, 2vw + 1rem, 2.4rem);
  font-weight: 800;
  letter-spacing: 0.2px;
}

.profile-email {
  color: var(--muted);
  margin-top: 6px;
  font-size: 0.95rem;
}

.stats-grid {
  display: grid;
  gap: 18px;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}

.stat-card {
  padding: 20px;
  border-radius: var(--radius);
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  display: flex;
  flex-direction: column;
  gap: 6px;
  box-shadow: var(--shadow);
}

.stat-value {
  font-size: 1.6rem;
  font-weight: 800;
}

.stat-label {
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--muted);
  font-size: 0.75rem;
}

.tab-container {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.tab-nav {
  background: rgba(0, 0, 0, 0.28);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: var(--radius);
  padding: 6px;
  box-shadow: var(--shadow);
}

.tab-list {
  list-style: none;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 0;
  padding: 0;
}

.tab-button {
  border: 1px solid transparent;
  background: transparent;
  color: var(--muted);
  font-weight: 600;
  letter-spacing: 0.35px;
  padding: 10px 16px;
  border-radius: 999px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition:
    background 0.2s ease,
    border-color 0.2s ease,
    color 0.2s ease,
    box-shadow 0.2s ease;
}

.tab-button:not(.active):hover {
  color: var(--text);
  border-color: rgba(247, 126, 45, 0.3);
}

.tab-button.active {
  color: #0a0a0a;
  background: linear-gradient(180deg, var(--accent), #ff9b52);
  border-color: rgba(247, 126, 45, 0.65);
  box-shadow: 0 8px 22px rgba(247, 126, 45, 0.25);
}

.tab-count {
  font-size: 0.75rem;
  font-weight: 600;
  padding: 2px 8px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.08);
  color: var(--muted);
}

.tab-button.active .tab-count {
  background: rgba(0, 0, 0, 0.18);
  color: #111;
}

.tab-panels {
  display: flex;
  flex-direction: column;
  gap: 22px;
}

.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
}

.stats-panel-content,
.submissions-panel-content,
.quests-panel-content {
  display: grid;
  gap: 22px;
}

.insight-grid {
  display: grid;
  gap: 16px;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}

.insight-card {
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: var(--radius);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  box-shadow: var(--shadow);
}

.insight-value {
  font-size: 1.4rem;
  font-weight: 800;
}

.insight-label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.35px;
  color: var(--muted);
}

.profile-section {
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  border-radius: var(--radius);
  border: 1px solid rgba(255, 255, 255, 0.05);
  padding: 24px;
  box-shadow: var(--shadow);
}

.profile-section > h2 {
  font-size: 1.2rem;
  margin-bottom: 18px;
  font-weight: 700;
}

.skills-layout {
  display: grid;
  gap: 20px;
  grid-template-columns: minmax(240px, 1fr) minmax(240px, 1.4fr);
  align-items: start;
}

.skills-radar {
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: var(--radius);
  padding: 18px 20px;
  box-shadow: var(--shadow);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.radar-title {
  font-size: 0.85rem;
  letter-spacing: 0.35px;
  text-transform: uppercase;
  color: var(--muted);
}

.radar-wrapper {
  display: grid;
  place-items: center;
}

.radar-chart {
  width: min(260px, 100%);
  height: auto;
}

.radar-grid {
  fill: rgba(255, 255, 255, 0.04);
  stroke: rgba(255, 255, 255, 0.06);
  stroke-width: 1;
}

.radar-axis {
  stroke: rgba(255, 255, 255, 0.08);
  stroke-width: 1;
}

.radar-data {
  fill: rgba(247, 126, 45, 0.18);
  stroke: rgba(247, 126, 45, 0.75);
  stroke-width: 2;
}

.radar-point {
  fill: var(--accent);
  stroke: rgba(10, 10, 10, 0.55);
  stroke-width: 2;
}

.radar-label {
  fill: var(--muted);
  font-size: 0.65rem;
  letter-spacing: 0.2px;
}

.skills-grid {
  display: grid;
  gap: 16px;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  min-width: 0;
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 18px;
  flex-wrap: wrap;
}

.section-header h2 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 700;
}

.section-pill {
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 0.75rem;
  letter-spacing: 0.3px;
  background: rgba(247, 126, 45, 0.15);
  color: var(--accent);
  border: 1px solid rgba(247, 126, 45, 0.35);
}

.skill-card {
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px 20px;
  border-radius: 14px;
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  box-shadow: var(--shadow);
}

.skill-card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
}

.skill-name {
  font-weight: 600;
  letter-spacing: 0.2px;
}

.skill-rank {
  font-size: 0.72rem;
  letter-spacing: 0.4px;
  text-transform: uppercase;
  padding: 4px 9px;
  border-radius: 999px;
  background: rgba(247, 126, 45, 0.14);
  color: var(--accent);
  border: 1px solid rgba(247, 126, 45, 0.28);
}

.skill-score-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
  color: var(--muted);
  font-size: 0.85rem;
}

.skill-score {
  font-size: 1.4rem;
  font-weight: 800;
  color: var(--text);
}

.skill-percent {
  font-size: 0.8rem;
  font-weight: 600;
  color: var(--accent);
}

.skill-progress {
  width: 100%;
  height: 8px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.08);
  overflow: hidden;
}

.skill-progress-fill {
  height: 100%;
  border-radius: inherit;
  background: linear-gradient(90deg, var(--accent), #ff9b52);
  transition: width 0.3s ease;
}

.skills-empty {
  margin: 12px 0 0;
  color: var(--muted);
  text-align: center;
  letter-spacing: 0.2px;
}

.card-grid {
  display: grid;
  gap: 18px;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
}

.infinite-sentinel {
  width: 100%;
  height: 1px;
}

.entry-card {
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.quest-card {
  position: relative;
}

.quest-card-action {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 36px;
  height: 36px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  background: rgba(10, 10, 10, 0.65);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: var(--muted);
  cursor: pointer;
  backdrop-filter: blur(5px);
  transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
}

.quest-card-action:hover,
.quest-card-action:focus-visible {
  transform: translateY(-1px);
  border-color: rgba(247, 126, 45, 0.55);
  background: rgba(247, 126, 45, 0.18);
  color: var(--text);
  box-shadow: 0 12px 28px rgba(247, 126, 45, 0.25);
}

.quest-card-action svg {
  width: 14px;
  height: 14px;
  display: block;
}

.quest-card-action svg path {
  fill: none;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.entry-thumb-wrapper {
  position: relative;
  aspect-ratio: 16 / 9;
  background: #111;
  overflow: hidden;
}

.entry-thumb {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.entry-card-body {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 18px 20px 20px;
}

.entry-title {
  font-size: 1rem;
  font-weight: 700;
  letter-spacing: 0.2px;
}

.entry-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 0.8rem;
  color: var(--muted);
}

.entry-description {
  font-size: 0.85rem;
  color: var(--muted);
  line-height: 1.5;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.chip-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.chip {
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.73rem;
  letter-spacing: 0.35px;
  text-transform: uppercase;
  color: var(--muted);
}

.chip.accent {
  background: rgba(247, 126, 45, 0.15);
  border-color: rgba(247, 126, 45, 0.45);
  color: var(--accent);
}

.chip.muted {
  background: rgba(255, 255, 255, 0.05);
  border-color: rgba(255, 255, 255, 0.08);
}

.xp-row {
  margin-top: 4px;
}

.panel-empty {
  text-align: center;
  padding: 40px 24px;
  border-radius: var(--radius);
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.05);
  color: var(--muted);
  font-size: 0.95rem;
  letter-spacing: 0.2px;
}

.empty-state {
  text-align: center;
  padding: 60px 30px;
  border-radius: var(--radius);
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: var(--shadow);
  color: var(--muted);
}

@media (max-width: 768px) {
  main.dashboard {
    margin-top: 24px;
  }

  .profile-card {
    flex-direction: column;
    text-align: center;
  }

  .skills-layout {
    grid-template-columns: 1fr;
  }

  .skills-radar {
    order: -1;
    padding: 16px;
  }

  .skills-grid {
    grid-template-columns: 1fr;
  }

  .tab-nav {
    padding: 8px;
  }

  .tab-list {
    gap: 6px;
  }

  .card-grid {
    grid-template-columns: 1fr;
  }

  .insight-grid {
    grid-template-columns: 1fr;
  }

  .section-header {
    justify-content: flex-start;
  }

  .section-header h2 {
    width: 100%;
  }
}
`;

  document.head.appendChild(style);
}
